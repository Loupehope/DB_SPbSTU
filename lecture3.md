- [Лекция 1](#1-Лекция)
  - Старый курс

- [Лекция 2](#2-Лекция)
	- [Кумулятивные статистики](#Кумулятивные-статистики)
	- [DB Time](#DB-Time)
	- [Free buffer waits](#Free-buffer-waits)
	- [Buffer busy waits](#Buffer-busy-waits)

- [Лекция 3](#3-Лекция)
	- [Baselines](#Baselines)
	- [DBMS_WORKLOAD_REPOSITORY](#DBMS_WORKLOAD_REPOSITORY)

- [Лекция 4](#4-Лекция)
	- Ничего полезного

- [Лекция 5](#5-Лекция)
	- [Метрика](#Метрика)
	- [Baseline](#Baseline)

- [Лекция 6](#6-Лекция)
	- [SYSTEM_MOVING_WINDOW](#SYSTEM_MOVING_WINDOW)
	- [Шаблоны опорных линий](#Шаблоны-опорных-линий)

- [Лекция 7](#7-Лекция)
	- [DEFAULT_MAINTANENCE_PLAN](#DEFAULT_MAINTANENCE_PLAN)
	- [Autotask Background Process](#Autotask-Background-Process)
	- [Active Session History](#Active-Session-History)
	- [Доступ к ASH](#Доступ-к-ASH)

- [Лекция 8](#8-Лекция)

- [Лекция 9](#9-Лекция)

# 1 Лекция
- [1 часть](https://github.com/Loupehope/DB_SPbSTU/blob/master/lecture.md#%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F)
- [2 часть](https://github.com/Loupehope/DB_SPbSTU/blob/master/lecture.md#%D0%B2%D1%82%D0%BE%D1%80%D0%B0%D1%8F-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F)

# 2 Лекция
**Кумулятивные статистики** - суммарные данные о количестве и производительности событий, которые прошли в БД с момента старта экземпляра:
- события ожидания (wait events) - инфа о сессиях, которые были вынуждены ожидать или в данный момент ожидают по различным причинам
- временная модель - набор статистик, которые представляют процент от времени БД для каждого типа событий

**Метрики**: кол-во произошедших в единицу времени событий (транзакция, секунда)

**Выборочные статистики** - хранятся после перезапуска экземпляра - на сессию, на SQL, службы

**Цели настройки**:
- Minimising response time
- Increasing throughput
- Increasing load capabilities
- Decreasing recovery time

**DB Time** - количество времени в миллисекундах, затраченное БД на выполнение пользовательских запросов (не включаются фоновые запросы, не простаивающие пользовательские сессии). Изменяется суммарно с момента запуска экземпляра.

**Free buffer waits** - время ожидания свободных буфферов в ОЗУ (DBWR), чтобы серверный процесс мог туда записать новый блок из файловой системы.

**Buffer busy waits** - сессия хочет получить доступ к блоку базы данных Buffer Cache (DBWR) - но не может, тк буффер занят сейчас - кто-то его уже изменяет

**enq: TX - index contention** - ожидание, связанное с работой индекса - ТХ - блокировка таблицы на уровне строк 

**Log file sync** - ожидание, связанна с Log Writer - перегружен и не успевает всё записать redo log файлы 

**db file sequential read** - ожидание, связанное с чтением данных из файла - серверный процесс пытается читать информацию из файла, но I/O слишком медленный

**DB Time** = DB wait time (нужна настройка экземпляра) + DB CPU time (нужна настройка SQL команд)

Time Model:
- V$SYS_TIME_MODEL
- V$SESS_TIME_MODEL

Динамические представления - предоставляют информацию об изменении состояния и условий в экземпляре (Доступ Sys, select_catalog_row) (ОЗУ)

Уровни статистики V&STATISTICS_LEVEL:
- Basic - автоматически статистики не собираются
- Typical - данные для статистики собираются на уровне сегментов
- All - дом статистики собираются из ОС

Системные статистики:
- V$STATNAME - названия статистик
- V$SYSSTAT - для SYS
- V$SESSTAT - статистики для всех сессий
- V$MYSTAT - статистики для текущей сессии
- V$SERVICESTAT - для служб

Классы ожиданий:
- V$SESSION_WAIT_CLASS
- V$SYSTEM_WAIT_CLASS
- V$SERVICE_WAIT_CLASS
- V$EVENT_NAME

- V$SESSION_WAIT - события и ресурсы, которые ожидает сессия

# 3 Лекция
Снепшоты хранятся в SYSAUX.
Baselines - опорные линии - снепшоты, когда БД работает нормально.

**DBMS_WORKLOAD_REPOSITORY** - для работы со снепшотами:
- Период хранения Retention указывается в минутах. По умолчанию – 8 дней. Минимальное значение – 1 день. При значении 0 автоматическая очистка отключается.
- Параметр Interval определяет интервал между снимками. Минимальное значение – 10 минут. Максимальное значение -100 лет. Значение по умолчанию – 60 минут.
- Параметр Topnsql – количество команд SQL, для которых необходимо собирать данные о производительности. Default - top 30.

Остальная лекция - скрины из EM.

# 4 Лекция

Ничего полезного - общие советы по поиску проблем в БД.

# 5 Лекция

- **Метрика** - скорость изменения кумулятивной статистики.
- **Alert** - событие, генерируемое при пересечении наблюдемой метрики порога.
- **Baseline** - данные (набор снимков), собираемые из нормально работающей БД для сравнения производительности.

# 6 Лекция

**Опорная линия** автоматического репозитория нагрузки содержит набор снимков автоматического репозитория нагрузки для “интересующего или эталонного” периода времени

Поддерживается одна опорная линия с подвижным окном:
- **SYSTEM_MOVING_WINDOW** - опорная линия с подвижным окном, которое соответствует последним 8 дням данных в автоматическом репозитории нагрузки.
- Создается автоматически в Oracle 11g.

**Шаблоны опорных линий** - позволяют состявлять расписание создания опорных линий для периодов времени в будущем:
- Для одного периода времени в будущем
- Повторяющееся расписание
- Когда конечное время для шаблона опорной линии изменится с будущего на прошедшее, процесс MMON обнаружит изменение и создаст опорную линию.

**Три метода сравнения метрик опорных линий**:
- Доля необычных значений по сравнению с данными опорной линии - пороги уровня значимости
- Значение близкое или превышающее пиковое значение по данным опорной линии - порого в процентах от максимума
- Величины порогов, основанные на фиксированных значениях - устанавливаются DBA

# 7 Лекция

Задачи автоматического обслуживания помогают:
- контролировать использование памяти;
- собирать статистики оптимизации;
- настраивать высоконагруженные команды SQL.

Выполнение задач приоритезировано:
- если задачи не имеют достаточного времени или ресурсов для завершения работы, то они перенаправляются в след. окно.
- когда задачи заполняют доступные окна, продолжительность и распределение ресурсов может потребоваться изменить.

Задачи автоматизации сопоставлены определенным окнам. Все дневные окна по умолчанию принадлежа Maintenance Window Group.

Когда окно обслуживания открывается, диспетчер ресурсов автоматически устанавливает **DEFAULT_MAINTANENCE_PLAN** для контроля ресурсов CPU, используемых задачами авотматизации обслуживания.

Для того, чтобы иметь возможность давать различные приоритеты каждой задаче во время окна обслуживания, с DEFAULT_MAINTENANCE_PLAN сопоставлены различные группы потребителей:
- **ORA$AUTOTASK_SUB_PLAN** -> **ORA$AUTOTASK_HIGH_URGENT_PLAN - наивысший приоритет**, ORA$AUTOTASK_HIGH_SUB_PLAN, ORA$AUTOTASK_HIGH_MEDIUM_PLAN.

**Autotask Background Process** (ABP) - функционирует как посредник между задачами автоматизации и Scheduler:
- Его главная задача - преобразовать задачи автоматизации в работы Autotask для выполнения Scheduler'ом.
- Обслуживает также историю выполнения всех задач и сохраняет их в частный репозиторий в табличном пространстве SYSAUX (можно посмотреть через DBA_AUTOTASK_TASK).
- Запускается процессом MMON при старте окна обслуживания.
- Существует только один процесс ABP для всех экземпляров.

**ADDM - диагностическое ПО, встроенное в Oracle**:
- Проверяет и анализирует информацию, помещенную в AWR с целью определения возможных проблем с производительностью.
- Сервер Oracle автоматически забирает статистику из SGA каждые 60 мин и сохраняет её в AWR в форме снимков (снепшотов).
- ADDM запускется MMON'ом для каждого экземпляра.
- Каждый раз при получении снимка ADDM запускается для выполнения анализа на интервале между двумя последними снимками. Такой подход позволяет предварительно контролировать экземпляр и определять узкие места.
- Результаты анализа ADDM сохраняются в AWR.

**ADDM использует DB time для определения**:
- компонентов базы данных, которые требуют анализа
- узких мест производительности

**ADDM проверяет затраченное DB time в двух независимых направлениях**:
- Первая размерность - DB time - при пользовательских запросах (подключение к БД, выполнение SQL команд)
- Вторая размерность - DB time - при использовании или ожидании ресурсов для выполнения пользовательских команд.

**Active Session History** - хранит историю в течение DB time:
- извлекает только выборки информации из V$SESSION.
- построен как кользевой буффер в памяти и предшествующая информация перезаписывается, когда это необходимо.
- память для ASH берется в SGA и фиксируется для времени жизни экземпляра - 2 МБ памяти на CPU.
- ASH не может превысить максимальную границу в 5% от величины shared_pool_size или от SGA_TARGET.

**ASH выборки активности сессии в системе включая**:
– SQL идентификатор команды SQL
– Номер объекта, номер файла, номер блока
– Идентификатор события ожидания параметры
– Идентификатор сессии и serial number сессии
– Имя приложения и операции (Module and action name) – Идентификатор клиента сессии

**ASH хранит историю в течение Database time**:
– Идентификатор хэша сервиса
– Блокирующая сессия (Blocking session)

**Доступ к ASH**:
- Dump a trace file
- V$Active_session_history
- DBA_HIST_ACTIVE_SESS_HISTORY
- ASH report
- EM

# 8 Лекция

**Служба** - это средство группирования сессий, которые выполняют один и тот же вид работы:
- обеспечивают одно-системное представление вместо многоэкземплярного представления
- представляет собой часть регулярных задач администрирования, которые обеспечивают динамическое выделение служб экземпляру
- является основой для высокой доступности соединений
- обеспечивает дополнительное измерение для настройки производительности

**Атрибуты службы**:
- Для службы с единственным экземпляром:
	- глобальное уникальное имя
	- сетевое имя
- Доп. атрибуты для большего кол-ва экземпляров:
	- цель настройки, характеристики отказоустойчивости и тд.

**Типы служб**:
- службы приложений
- внутренние службы:
	- SYS$BACKGROUND - используется только фоновыми процессами
	- SYS$USERS - служба по умолчанию для пользовательских сессий, не ассоциированных со службами
	- не могут быть удалены или изменены
- предел - 118 служб на БД:
	- 116 служб приложений
	- 2 внутренние службы

**Создание служб**:
- вручную - с помощью DBMS_SERVICE.CREATE_SERVICE(service_name, network_name) - для одного экземпляра
- создаются автоматически при старте экземпляра на основе параметра инициализации SERVICE_NAMES (initora)
- сервисы обслуживаются в словаре данных

**Возможности на уровне служб**:
- словарь данных обслуживает службы
- AWR оценивает производительность служб
- DRM использует службы для установки приоритетов

 **Использование служб с клиентскими приложениями**:
- Приложения и пуллы соединений среднего уровня выбирают службу, используя дескриптор TNS соединения.
- Выбранная служба должна соответствовать службе, созданной с испльзованием SRVCTL или DBCA.

**Диспетчер ресурсов**:
- назначает относительный приоритет служб в экземпляре путем привязывания служб напрямую к группе потребителей.
- группы потребителей ресурсов авотматически назначаются сессиям на основе служб сессии
- работа получает приоритет от службы внутри одного экземплляра

**Были слайды про jobs и планировщике, но этого в лабах нет**

**Использование служб с порогами метрик**:
- можно определить пороги на уровне служб:
   - elapsed_time_per_call - время отклика на вызов - измеряет время отклика для каждого пользовательского вызова на соответствующей службы (мкс).
   - cpu_time_per_call - 
- предупреждения, сгенерированные сервером, вызываются нарушением порогов
- мониторинг метрик осуществляется AWR
- v$servicemetric

**Агрегация и трассировка**:
- при настройке произвоительности для измерения нагрузки статистики всегда агрегируются на уровне служб
- доп уровни:
    - Service_name
    - MODULE - период работы конкретного приложения в течение часа
    - ACTION - конкретный фрагмент приложения, то есть эпизод выдачи приложением определенной последовательности команд SQL
    - Комбинация Service_name, Module, Action

**trcsess** - консолидирует результаты трассировки из выделенных файлов трассировки на основе критерийев session id, name...

**tkprof** - после объединения инфы о трассировке в один файл надо его представить в читабельном виде

# 9 Лекция

**Фазы выполнения команды SQL:**
- **open** - открытие курсора  
- **parse:**
	- проверка семантики и синтаксиса (всегда)
	- проверка прав на выполненеи у вызывающего (всегда)
	- поиск аналогичного разобранного кода в Shared Pool (soft parse)
	- определяет план выполнения (hard parse)

- **bind** - подключение связанных переменных:
	 - проверка команд для связанных переменных
	 - назначение / переназначение для связанной переменной
	 - улучшает производительнойсть за счет использования shared cursor
	 
- **execute** - выполнение:
	- выполняется SQL команда
	- выполняются операции I/O и сортировка команд DML


- **fetch** - извлечение - к запросам и командам DML - которые возвращают новые данные - returning clause:
	- выбираются строки из запроса
	- сортировка результатов
	- используется механизм ивлечения нескольких строк (array fetch)


- **close** - закрытие курсора

**Library Cache (SGA) и Sqlarea (PGA)** - для хранения SQL и блоков PL/SQL:
- Преобразет команду в коды ASCII
- Вычисляет хэш
- Размещает курсор на хэш цепочку

**DML выполняется в две фазы:**
- parse - разбор команды
- execute - выполнение

**Процесс выполнения DML команды:**
- Если данные и блоки отката для изменяемых в процессе DML данных еще не помещены в буферный кэш, то серверный процесс считывает их с диска в буферный кэш. Серверный процесс при этом блокирует строки, которые будут модифицированы.
- Серверный процесс затем применяет изменения данных, запрашиваемые в DML к данным, прочитанным в буферный кэш и записывает данные в буфер отката. Изменения записываются в redo log buffer перед тем, как данные будут изменены в буферном кэше и буферах отката. Эта технология применения изменений называется "упреждающее логирование" (write-ahead logging)
- Буферы отката содержат значения данных перед модификацией. Буферы отката используются для хранения снимка данных до изменения и таким образом изменения внесенные DML операциями могут быть отменены в случае необходимости. В буферы данных записываются изменения данных.
- Пользователь получает ответ от операции DML (сколько строк изменено в процессе выполнения операции)

**СУБД Oracle использует механизм fast commit, который гарантирует что примененные изменения могут быть восстановлены в случае сбоя экземпляра:**
- Когда происходит commit транзакции, БД Oracle присваивает транзакции уникальный системный номер изменения (SCN).
- SCN предоставляет возможность проводить проверку целостности данных вне зависимости от даты и времени установленной в операционной системе.

**Когда запускается COMMIT, выполняются следующие шаги:**
- Серверный процесс помещает запись о commit c SCN в redo log buffer.
- Фоновый процесс LGWR записывает данные повтора в redo log файлы. Это гарантирует, что в случае отказа экземпляра, данные об изменениях произведенных транзакцией не будут потеряны.
- Серверный процесс отправляет сообщение об окончании транзакции пользовательскому процессу.
- DBWR в итоге записывает актуальные данные из грязных блоков на диск, используя для этого свой внутренний временной механизм и настройки выполнения checkpoint.

**Роль стоимостного оптимизатора**:
- Оптимизатор запросов Oracle определяет наиболее эффективный план выполнения команды SQL и представляет собой важный этап в выполнении запроса
- Оптимизатор:
	– Вычисляет выражения и условия
	– Использует объектные и системные статистики
	– Осуществляет трансформацию команд
	– Решает, каким способом осуществить соединение таблиц
	– Решает, какой путь доступа к данным наиболее эффективен
	
**Режимы работы оптимизатора**:
- Run-time optimizer, который создает план выполнения во время выполнения (at run time). В этом режиме оптимизатор ограничен во времени и может рассмотреть лишь ограниченное число альтернатив.
- Automatic Tuning Optimizer (ATO) - в этом режиме оптимизатору выделяется намного больше времени для рассмотрения большего количества опций и сбора статистик.

**Физическое чтение** - чтение с диска
**Логическое чтение** - чтение из оперативной памяти SGA Buffer Cache

**План выполнения (execution plan)** – это набор шагов, которые выполняет оптимизатор, когда исполняется команда SQL и выполняется операция:
- Определение текущего плана выполнения
- Выяснение влияния индексов
- Определение путей доступа (access paths), например, full table scan (индексы не используются) или index range scan (использование индекса по диапазону)
- Проверка эффективности индексов
- Проверка, какой план выполнения может быть использован

**Команда EXPLAIN PLAN:**
- Генерирует план выполнения оптимизатора 
- Сохраняет план в таблице PLAN
- Сама команда не выполняется

**Команда EXPLAIN PLAN: Output**:
- Символом * отмечаются операции, которые имеют информацию о предикатах (Access predicate, Index filter predicate, Table level filter predicate)

**Режим AUTOTRACE – удобное средство диагностики для настройки команд SQL:**
- OFF - Отключает средство AUTOTRACE для команд SQL 
- ON - Включает средство AUTOTRACE для команд SQL
- TRACEONLY - подавляет вывод результата выполнения команды
- EXPLAIN - Отображает планы выполнения, но не отображает статистики
- STATISTICS - Отображает статистики, но не отображает планы выполнения

**Наиболее важные статистики:**
- db block gets - Количество логических I/O, которые пришлось выполнить для получения текущих данных - чтения текущих блоков из buffer cache
- consistent gets - Количество чтений блоков из buffer cache, которые хранят данные undo
- physical reads - Количество блоков, прочитанных с диска
- redo size - Объем сгенерированной информации повтора (redo) (для DML команд)
- sorts (memory) - Количество сортировок, выполненных в памяти
- sorts (disk) - Количество сортировок, выполненных с использованием временного хранения на диске

Средство **SQL Trace** позволяет получать информацию по производительности на индивидуальные команды SQL.

**trcsess** - консолидирует результаты трассировки из выделенных файлов трассировки на основе критерийев session id, name...

**tkprof** - после объединения инфы о трассировке в один файл надо его представить в читабельном виде

**Опции команды TKPROF**:
- SYS - Отключает вывод списка рекурсивных команд SQL, выполняемых пользователем SYS (не включает рекурсивные команды в отчет)
- EXPLAIN - Выполняет команду EXPLAIN PLAN в заданной схеме. (username/password)

**Отчет TKPROF:**
- Count - Количество раз выполнения процедуры
- CPU - Количество секунд на обработку
- Elapsed Общее количество секунд на выполнение
- Disk - Количество прочитанных физических блоков
- Query - Количество логических буферов, прочитанных для последовательного чтения
- Current - Количество логических буферов, прочитанных в текущем режиме
- Rows - Количество строк, обработанных в процессе выборки или выполнения

**Результаты TKPROF включают также информацию о:**
- Recursive SQL statements - дополнительные команды SQL, которые ораклу пришлось выполнить обращаясь к различным областям памяти SGA или системным таблицам
- Library cache misses - случаи, котгда не удалось найти инфу в Library cache
- Parsing user ID
- Execution plan
- Optimizer mode or hint - режим оптимизации или подсказка
- Row source operation (cr = consistent reads, pw = physical writes, pr = physical reads, time = time (in microseconds), cost = estimated cost , size = estimates bytes of row source, card=cardinality(number of rows).)

# 10 Лекция

**Блок запроса может определен как:**
- полный запрос (complete query),
- подзапрос (nested subquery),
- подзапрос в разделе FROM (nonmerged view).

**Оценщик генерирует три типа оценок (measures):**
- Селективность (Selectivity):
	- Определяется как отношение кол-ва нужных строк к общему числу
	- Селективность влияет на оценки стоимости I/O и на стоимость сортировки.
	- Значение селективности находится в диапазоне значений от 0.0 до 1.0.
	- Когда доступны статистики, оценщик (estimator) использует их для оценки.
	- Когда статистики недоступны, оценщик использует значения по умолчанию (default values) или динамическую выборку (dynamic sampling).
- Кардинальность (Cardinality):
	- Кол-во нужных строк
- Стоимость (Cost):
	- Стоимость представляет собой количество единиц работы или ресурсов, требуемое для выполнения операции.
	- Формула состоит из трех основных измерений:
		• Предположительное время, требуемое для выполнения всех операций беспорядочного одноблочного чтения
		• Предположительное время выполнения многоблочного чтения
		• Предположительное время CPU которое будет затрачено на обработку выражения

Количество возможных планов для блока запроса пропорционально количеству соединений (join items) в разделе FROM.

**Использование подсказок** /\*+ /:
- Это директивы (советы) оптимизатору
- Требуют изменения кода
- Полезны для тестирования определенных путей доступа (access paths)
- Должны обслуживаться путем обновления (upgrades) 

**Подсказки бывают:**
- одно-табличные (single-table)
- многотабличные (multitable)
- блока запроса (query block)
- командные (statement).

**Поведением оптимизатора можно управлять при помощи следующих параметров инициализации:**
- CURSOR_SHARING:
	- конвертирует литеральные величины в командах SQL в связанные переменные (bind variables). Конвертация величин может повлиять на планы выполнения команд SQL. Оптимизатор генерирует план выполнения, основываясь на наличии связанных (bind) переменных, а не на наличии литеральных величин. Возможные значения: FORCE, SIMILAR, EXACT (по умолчанию)
- DB_FILE_MULTIBLOCK_READ_COUNT:
	- определяет количество блоков, которое считывается за одну операцию ввода/вывода при полном сканировании таблицы (full table scan) или при индексном быстром полном сканировании (index fast-full scan). Более высокие значения этого параметра приводят к более низким оценкам стоимости для полных сканирований таблиц и могут привести к тому, что оптимизатор отдаст предпочтение полному сканированию по сравнению с индексным сканированием.
В Oracle Database 11g этот параметр устанавливается автоматически и использует по умолчанию значение 8.
- OPTIMIZER_INDEX_CACHING:
	- контролирует стоимость индексных проб (index probes).
- OPTIMIZER_INDEX_COST_ADJ:
	- может быть использован для настройки стоимости индексных проб.
- PGA_AGGREGATE_TARGET:
	- втоматически управляет количеством памяти, выделяемым для сортировок и операций хэш-соединений (hash joins), когда для параметра WORKAREA_SIZE_POLICY установлено значение AUTO.

**Дополнительные параметры оптимизатора:**
– OPTIMIZER_MODE:
	- устанавливает подход, который использует оптимизатор для определения наилучшего плана для экземпляра или сессии. Возможные значения – ALL_ROWS, FIRST_ROWS_n (n=1,10,100,1000), FIRST_ROWS. По умолчанию ALL_ROWS
– OPTIMIZER_FEATURES_ENABLE:
	- сдвигает поведение оптимизатора к более ранним версиям, контролируя набор параметров оптимизатора, большинство из которых является недокументированными.

**Пути доступа (access paths) – это методы, при помощи которых данные извлекаются из базы данных**:
- Full table scan:
	- Отсутствие индекса
	- Большое количество
	- Увеличение скорости за счет многоблочных операций ввода/вывода данных
	- Маленькая таблица 
	- Сканируются все строки ниже HWM
- Row ID scan:
	- Row ID определяет файл данных и блок данных, содержащих строку, а также расположение строки в этом блоке.
- Sample table scan:
	- извлекает случайную выборку данных из простой таблицы или сложной команды SELECT.
Такой метод доступа используется, когда раздел FROM команды включает опцию SAMPLE или SAMPLE BLOCK.
- Index scan
- Cluster scan

**Индекс** – необязательный объект базы данных, который логически и физически не зависит от данных таблицы.

<Очень много про индексы, легче слайды полистать>

**Index Full Scan**:
- Full scan возможен, если предикат ссылается на один из столбцов индекса.
- Нет необходимости, чтобы предикат использовал ведущий столбец индекса.
- Full scan может быть использован для того, чтобы устранить операции сортировки, поскольку данные сортируются по ключу индекса.

Full scan возможен также, когда предикат отсутствует, но выполняются два условия:
- Все столбцы в таблице, на которые есть ссылки в запросе, включены в индекс.
- По крайней мере один из столбцов индекса не допускает пустых значений (is not NULL).

**Index Fast Full Scan**:
- индекс содержит все столбцы, которые нужны запросу, и
- по меньшей мере один столбец в ключе индекса не допускает пустых значений (is not NULL).
- Эта операция читает весь индекс, используя многоблочное чтение (multiblock reads) (в отличие от full index scan).
- Fast full index scan быстрее нормального Full index scan, поскольку он может использовать многоблочный ввод/вывод как и табличном сканировании.
